var b=Object.defineProperty;var y=(h,e,t)=>e in h?b(h,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):h[e]=t;var o=(h,e,t)=>y(h,typeof e!="symbol"?e+"":e,t);(function(){const e=document.createElement("link").relList;if(e&&e.supports&&e.supports("modulepreload"))return;for(const a of document.querySelectorAll('link[rel="modulepreload"]'))s(a);new MutationObserver(a=>{for(const n of a)if(n.type==="childList")for(const i of n.addedNodes)i.tagName==="LINK"&&i.rel==="modulepreload"&&s(i)}).observe(document,{childList:!0,subtree:!0});function t(a){const n={};return a.integrity&&(n.integrity=a.integrity),a.referrerPolicy&&(n.referrerPolicy=a.referrerPolicy),a.crossOrigin==="use-credentials"?n.credentials="include":a.crossOrigin==="anonymous"?n.credentials="omit":n.credentials="same-origin",n}function s(a){if(a.ep)return;a.ep=!0;const n=t(a);fetch(a.href,n)}})();/**
 * @license
 * SPDX-License-Identifier: Apache-2.0
*/const f="dailyDinchariyaSheetUrl";let S=class{constructor(){o(this,"masterTasks",[]);o(this,"todayInstances",[]);o(this,"taskListEl",document.getElementById("task-list"));o(this,"pointsValueEl",document.getElementById("points-value"));o(this,"streakValueEl",document.getElementById("streak-value"));o(this,"progressCircleEl",document.getElementById("progress-circle"));o(this,"progressTextEl",document.getElementById("progress-text"));o(this,"allDoneEl",document.getElementById("all-done"));o(this,"progressRingRadius",0);o(this,"sheetUrlInputEl",document.getElementById("sheet-url-input"));o(this,"loadSheetBtnEl",document.getElementById("load-sheet-btn"));o(this,"loaderStatusEl",document.getElementById("loader-status"));this.init()}init(){this.progressRingRadius=this.progressCircleEl.r.baseVal.value,this.progressCircleEl.style.strokeDasharray=`${this.progressRingRadius*2*Math.PI} ${this.progressRingRadius*2*Math.PI}`,this.progressCircleEl.style.strokeDashoffset=`${this.progressRingRadius*2*Math.PI}`,this.setupEventListeners(),this.loadInitialData()}setupEventListeners(){this.loadSheetBtnEl.addEventListener("click",()=>this.handleLoadSheetClick())}loadInitialData(){const e=localStorage.getItem(f);e&&(this.sheetUrlInputEl.value=e,this.loadTasksFromUrl(e))}handleLoadSheetClick(){const e=this.sheetUrlInputEl.value.trim();e&&this.loadTasksFromUrl(e)}setLoaderState(e,t=!1,s=!1){this.loaderStatusEl.textContent=e,this.loaderStatusEl.className=t?"error":"success",this.loadSheetBtnEl.disabled=s,s?this.loadSheetBtnEl.textContent="Loading...":this.loadSheetBtnEl.textContent="Load Tasks"}getCsvUrl(e){if(e.includes("/pub?output=csv"))return e;if(e.includes("/pubhtml"))return e.replace("/pubhtml","/pub?output=csv");const t=e.match(/spreadsheets\/d\/([a-zA-Z0-9-_]+)/);if(t){const s=t[1];let a="0";const n=e.match(/gid=([0-9]+)/);return n&&(a=n[1]),`https://docs.google.com/spreadsheets/d/${s}/export?format=csv&gid=${a}`}throw new Error("Invalid or unsupported Google Sheet URL. Please use the 'Share' link or the 'Publish to web' CSV link.")}async loadTasksFromUrl(e){this.setLoaderState("Loading tasks...",!1,!0),this.masterTasks=[],this.todayInstances=[],this.render();try{const t=this.getCsvUrl(e),s=await fetch(t);if(!s.ok)throw new Error(`Failed to fetch data. Status: ${s.status}. Ensure the sheet is public ('Anyone with link') or published.`);const a=await s.text();this.parseMasterTasks(a),this.generateTodayInstances(),this.render(),localStorage.setItem(f,e),this.setLoaderState(`Successfully loaded ${this.masterTasks.length} tasks!`,!1,!1)}catch(t){console.error(t);const s=t instanceof Error?t.message:"An unknown error occurred.";this.setLoaderState(`Error: ${s}`,!0,!1),localStorage.removeItem(f)}}slug(e){return e.toLowerCase().replace(/\s+/g,"_").replace(/[^a-z0-9_]/g,"")}parseMasterTasks(e){const t=e.split(/\r\n|\n/).slice(1);let s=null;t.forEach(a=>{if(!a.trim())return;const n=a.split(",").map(d=>d.replace(/"/g,"").trim()),[i,l,r,c,u,p,m,,,,,k]=n;if(i){const d=this.slug(i),g=this.parseDays(m);s={id:d,name:i,points:parseInt(r,10)||0,timeStart:u||void 0,timeEnd:p||void 0,daysOfWeek:g,subtasks:[],active:k==="TRUE"},this.masterTasks.push(s)}else if(l&&s){const d=this.slug(s.name+"_"+l);s.subtasks.push({id:d,name:l,subPoints:c?parseInt(c,10):void 0})}})}parseDays(e){const t=["Mon","Tue","Wed","Thu","Fri","Sat","Sun"];return!e||e.toLowerCase()==="all"?t:e.toLowerCase()==="weekdays"?["Mon","Tue","Wed","Thu","Fri"]:e.toLowerCase()==="weekend"?["Sat","Sun"]:e.split(",").map(s=>s.trim()).filter(s=>t.includes(s))}isEligibleToday(e,t){if(!e.active)return!1;const a=["Sun","Mon","Tue","Wed","Thu","Fri","Sat"][t.getDay()];return e.daysOfWeek.includes(a)}generateTodayInstances(){const e=new Date;this.todayInstances=this.masterTasks.filter(t=>this.isEligibleToday(t,e)).map(t=>({id:t.id,task:t,completed:!1,subtaskCompletion:t.subtasks.reduce((s,a)=>(s[a.id]=!1,s),{})}))}updateProgress(){let e=0,t=0;this.todayInstances.forEach(n=>{if(t+=n.task.points,n.completed)e+=n.task.points;else if(n.task.subtasks.length>0){const i=n.task.subtasks.some(r=>r.subPoints!==void 0);let l=0;if(i)n.task.subtasks.forEach(r=>{n.subtaskCompletion[r.id]&&(l+=r.subPoints||0)});else{const r=Object.values(n.subtaskCompletion).filter(Boolean).length;if(n.task.subtasks.length>0){const c=n.task.points/n.task.subtasks.length;l=r*c}}e+=Math.min(l,n.task.points)}});const s=t>0?e/t:0,a=this.progressRingRadius*2*Math.PI;this.progressCircleEl.style.strokeDashoffset=`${a-s*a}`,this.progressTextEl.textContent=`${Math.round(s*100)}%`,this.pointsValueEl.textContent=`${Math.round(e)} / ${t}`,this.todayInstances.length>0&&s===1?this.allDoneEl.classList.remove("hidden"):this.allDoneEl.classList.add("hidden")}render(){this.taskListEl.innerHTML="",this.todayInstances.length===0&&this.masterTasks.length>0?this.allDoneEl.classList.remove("hidden"):(this.allDoneEl.classList.add("hidden"),this.todayInstances.forEach(e=>{this.taskListEl.appendChild(this.createTaskElement(e))})),this.updateProgress()}createTaskElement(e){const t=document.createElement("div");t.className="task-item",t.dataset.instanceId=e.id,e.completed&&t.classList.add("completed");const s=e.task.subtasks.length>0;let a="";if(e.task.timeStart&&e.task.timeEnd&&(a=`${e.task.timeStart} - ${e.task.timeEnd}`),t.innerHTML=`
      <div class="task-header">
        <label class="checkbox-container">
          <input type="checkbox" ${e.completed?"checked":""}>
          <span class="checkmark"></span>
        </label>
        <h2>${e.task.name}</h2>
        <div class="task-meta">
          <span>${a}</span>
          <span class="points-pill">${e.task.points} pts</span>
        </div>
      </div>
      ${s?'<div class="subtask-list"></div>':""}
    `,t.querySelector('input[type="checkbox"]').addEventListener("change",n=>{this.handleTaskToggle(e.id,n.target.checked)}),s){const n=t.querySelector(".subtask-list");e.task.subtasks.forEach(i=>{n.appendChild(this.createSubtaskElement(e,i))})}return t}createSubtaskElement(e,t){const s=document.createElement("div"),a=e.subtaskCompletion[t.id];return s.className="subtask-item",a&&s.classList.add("completed"),s.dataset.subtaskId=t.id,s.innerHTML=`
      <label class="checkbox-container">
        <input type="checkbox" ${a?"checked":""}>
        <span class="checkmark"></span>
      </label>
      <p>${t.name}</p>
      ${t.subPoints?`<span class="points-pill">${t.subPoints} pts</span>`:""}
    `,s.querySelector("input").addEventListener("change",n=>{this.handleSubtaskToggle(e.id,t.id,n.target.checked)}),s}handleTaskToggle(e,t){const s=this.todayInstances.find(a=>a.id===e);s&&(s.completed=t,Object.keys(s.subtaskCompletion).forEach(a=>{s.subtaskCompletion[a]=t}),this.rerenderInstance(s),this.updateProgress())}handleSubtaskToggle(e,t,s){const a=this.todayInstances.find(i=>i.id===e);if(!a)return;a.subtaskCompletion[t]=s;const n=Object.values(a.subtaskCompletion).every(Boolean);a.completed=n,this.rerenderInstance(a),this.updateProgress()}rerenderInstance(e){const t=this.taskListEl.querySelector(`[data-instance-id="${e.id}"]`);if(t){const s=this.createTaskElement(e);t.replaceWith(s)}}};document.addEventListener("DOMContentLoaded",()=>{new S});/**
 * @license
 * SPDX-License-Identifier: Apache-2.0
*/const E="dailyDinchariyaSheetUrl";class I{constructor(){o(this,"masterTasks",[]);o(this,"todayInstances",[]);o(this,"taskListEl",document.getElementById("task-list"));o(this,"pointsValueEl",document.getElementById("points-value"));o(this,"streakValueEl",document.getElementById("streak-value"));o(this,"progressCircleEl",document.getElementById("progress-circle"));o(this,"progressTextEl",document.getElementById("progress-text"));o(this,"allDoneEl",document.getElementById("all-done"));o(this,"progressRingRadius",0);o(this,"sheetUrlInputEl",document.getElementById("sheet-url-input"));o(this,"loadSheetBtnEl",document.getElementById("load-sheet-btn"));o(this,"loaderStatusEl",document.getElementById("loader-status"));this.init()}init(){this.progressRingRadius=this.progressCircleEl.r.baseVal.value,this.progressCircleEl.style.strokeDasharray=`${this.progressRingRadius*2*Math.PI} ${this.progressRingRadius*2*Math.PI}`,this.progressCircleEl.style.strokeDashoffset=`${this.progressRingRadius*2*Math.PI}`,this.setupEventListeners(),this.loadInitialData()}setupEventListeners(){this.loadSheetBtnEl.addEventListener("click",()=>this.handleLoadSheetClick())}loadInitialData(){const e=localStorage.getItem(E);e&&(this.sheetUrlInputEl.value=e,this.loadTasksFromUrl(e))}handleLoadSheetClick(){const e=this.sheetUrlInputEl.value.trim();e&&this.loadTasksFromUrl(e)}setLoaderState(e,t=!1,s=!1){this.loaderStatusEl.textContent=e,this.loaderStatusEl.className=t?"error":"success",this.loadSheetBtnEl.disabled=s,s?this.loadSheetBtnEl.textContent="Loading...":this.loadSheetBtnEl.textContent="Load Tasks"}getCsvUrl(e){if(e.includes("/pub?output=csv"))return e;if(e.includes("/pubhtml"))return e.replace("/pubhtml","/pub?output=csv");const t=e.match(/spreadsheets\/d\/([a-zA-Z0-9-_]+)/);if(t){const s=t[1];let a="0";const n=e.match(/gid=([0-9]+)/);return n&&(a=n[1]),`https://docs.google.com/spreadsheets/d/${s}/export?format=csv&gid=${a}`}throw new Error("Invalid or unsupported Google Sheet URL. Please use the 'Share' link or the 'Publish to web' CSV link.")}async loadTasksFromUrl(e){this.setLoaderState("Loading tasks...",!1,!0),this.masterTasks=[],this.todayInstances=[],this.render();try{const t=this.getCsvUrl(e),s=await fetch(t);if(!s.ok)throw new Error(`Failed to fetch data. Status: ${s.status}. Ensure the sheet is public ('Anyone with link') or published.`);const a=await s.text();this.parseMasterTasks(a),this.generateTodayInstances(),this.render(),localStorage.setItem(E,e),this.setLoaderState(`Successfully loaded ${this.masterTasks.length} tasks!`,!1,!1)}catch(t){console.error(t);const s=t instanceof Error?t.message:"An unknown error occurred.";this.setLoaderState(`Error: ${s}`,!0,!1),localStorage.removeItem(E)}}slug(e){return e.toLowerCase().replace(/\s+/g,"_").replace(/[^a-z0-9_]/g,"")}parseMasterTasks(e){const t=e.split(/\r\n|\n/).slice(1);let s=null;t.forEach(a=>{if(!a.trim())return;const n=a.split(",").map(d=>d.replace(/"/g,"").trim()),[i,l,r,c,u,p,m,,,,,k]=n;if(i){const d=this.slug(i),g=this.parseDays(m);s={id:d,name:i,points:parseInt(r,10)||0,timeStart:u||void 0,timeEnd:p||void 0,daysOfWeek:g,subtasks:[],active:k==="TRUE"},this.masterTasks.push(s)}else if(l&&s){const d=this.slug(s.name+"_"+l);s.subtasks.push({id:d,name:l,subPoints:c?parseInt(c,10):void 0})}})}parseDays(e){const t=["Mon","Tue","Wed","Thu","Fri","Sat","Sun"];return!e||e.toLowerCase()==="all"?t:e.toLowerCase()==="weekdays"?["Mon","Tue","Wed","Thu","Fri"]:e.toLowerCase()==="weekend"?["Sat","Sun"]:e.split(",").map(s=>s.trim()).filter(s=>t.includes(s))}isEligibleToday(e,t){if(!e.active)return!1;const a=["Sun","Mon","Tue","Wed","Thu","Fri","Sat"][t.getDay()];return e.daysOfWeek.includes(a)}generateTodayInstances(){const e=new Date;this.todayInstances=this.masterTasks.filter(t=>this.isEligibleToday(t,e)).map(t=>({id:t.id,task:t,completed:!1,subtaskCompletion:t.subtasks.reduce((s,a)=>(s[a.id]=!1,s),{})}))}updateProgress(){let e=0,t=0;this.todayInstances.forEach(n=>{if(t+=n.task.points,n.completed)e+=n.task.points;else if(n.task.subtasks.length>0){const i=n.task.subtasks.some(r=>r.subPoints!==void 0);let l=0;if(i)n.task.subtasks.forEach(r=>{n.subtaskCompletion[r.id]&&(l+=r.subPoints||0)});else{const r=Object.values(n.subtaskCompletion).filter(Boolean).length;if(n.task.subtasks.length>0){const c=n.task.points/n.task.subtasks.length;l=r*c}}e+=Math.min(l,n.task.points)}});const s=t>0?e/t:0,a=this.progressRingRadius*2*Math.PI;this.progressCircleEl.style.strokeDashoffset=`${a-s*a}`,this.progressTextEl.textContent=`${Math.round(s*100)}%`,this.pointsValueEl.textContent=`${Math.round(e)} / ${t}`,this.todayInstances.length>0&&s===1?this.allDoneEl.classList.remove("hidden"):this.allDoneEl.classList.add("hidden")}render(){this.taskListEl.innerHTML="",this.todayInstances.length===0&&this.masterTasks.length>0?this.allDoneEl.classList.remove("hidden"):(this.allDoneEl.classList.add("hidden"),this.todayInstances.forEach(e=>{this.taskListEl.appendChild(this.createTaskElement(e))})),this.updateProgress()}createTaskElement(e){const t=document.createElement("div");t.className="task-item",t.dataset.instanceId=e.id,e.completed&&t.classList.add("completed");const s=e.task.subtasks.length>0;let a="";if(e.task.timeStart&&e.task.timeEnd&&(a=`${e.task.timeStart} - ${e.task.timeEnd}`),t.innerHTML=`
      <div class="task-header">
        <label class="checkbox-container">
          <input type="checkbox" ${e.completed?"checked":""}>
          <span class="checkmark"></span>
        </label>
        <h2>${e.task.name}</h2>
        <div class="task-meta">
          <span>${a}</span>
          <span class="points-pill">${e.task.points} pts</span>
        </div>
      </div>
      ${s?'<div class="subtask-list"></div>':""}
    `,t.querySelector('input[type="checkbox"]').addEventListener("change",n=>{this.handleTaskToggle(e.id,n.target.checked)}),t.querySelector(".task-header").addEventListener("click",n=>{n.target.closest(".checkbox-container")||s&&t.classList.toggle("expanded")}),s){const n=t.querySelector(".subtask-list");e.task.subtasks.forEach(i=>{n.appendChild(this.createSubtaskElement(e,i))})}return t}createSubtaskElement(e,t){const s=document.createElement("div"),a=e.subtaskCompletion[t.id];return s.className="subtask-item",a&&s.classList.add("completed"),s.dataset.subtaskId=t.id,s.innerHTML=`
      <label class="checkbox-container">
        <input type="checkbox" ${a?"checked":""}>
        <span class="checkmark"></span>
      </label>
      <p>${t.name}</p>
      ${t.subPoints?`<span class="points-pill">${t.subPoints} pts</span>`:""}
    `,s.querySelector("input").addEventListener("change",n=>{this.handleSubtaskToggle(e.id,t.id,n.target.checked)}),s}handleTaskToggle(e,t){const s=this.todayInstances.find(a=>a.id===e);s&&(s.completed=t,Object.keys(s.subtaskCompletion).forEach(a=>{s.subtaskCompletion[a]=t}),this.rerenderInstance(s),this.updateProgress())}handleSubtaskToggle(e,t,s){const a=this.todayInstances.find(i=>i.id===e);if(!a)return;a.subtaskCompletion[t]=s;const n=Object.values(a.subtaskCompletion).every(Boolean);a.completed=n,this.rerenderInstance(a),this.updateProgress()}rerenderInstance(e){const t=this.taskListEl.querySelector(`[data-instance-id="${e.id}"]`);if(t){const s=this.createTaskElement(e);t.classList.contains("expanded")&&s.classList.add("expanded"),t.replaceWith(s)}}}document.addEventListener("DOMContentLoaded",()=>{new I});
